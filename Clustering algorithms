import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin_min


def balanced_kmeans(X, k):
    n = len(X)
    cluster_size = n // k

    # Initialize KMeans++ to get initial cluster centers
    kmeans = KMeans(n_clusters=k, init='k-means++').fit(X)
    means = kmeans.cluster_centers_

    # Assign points to their nearest cluster initially
    labels, distances_to_nearest = pairwise_distances_argmin_min(X, means)
    
    # Compute distances to all clusters
    all_distances = np.linalg.norm(X[:, np.newaxis] - means, axis=2)
    
    # Benefit of best vs worst cluster
    benefit = all_distances.min(axis=1) - all_distances.max(axis=1)

    # Sort points based on the benefit (descending order)
    points_sorted_by_benefit = np.argsort(-benefit)

    # Initialize clusters with max size as `cluster_size`
    clusters = {i: [] for i in range(k)}

    # Assign points to preferred clusters
    for i in points_sorted_by_benefit:
        preferred_cluster = labels[i]
        if len(clusters[preferred_cluster]) < cluster_size:
            clusters[preferred_cluster].append(i)
        else:
            # Resort remaining points without considering the full cluster
            for j in range(k):
                if len(clusters[j]) < cluster_size:
                    clusters[j].append(i)
                    break

    # Recalculate final labels
    final_labels = np.zeros(n, dtype=int)
    for cluster, points in clusters.items():
        for point in points:
            final_labels[point] = cluster

    return final_labels, kmeans

# Example usage
n = 1000
new_random_plots = 100
k = 10 # Number of clusters

# Generate a 2D array of n random points
X = np.random.rand(n, 2)


y_kmeans, kmeans = balanced_kmeans(X, k)


# Calculate the number of points in each cluster
counts = np.bincount(y_kmeans)
mean_count = np.mean(counts)
max_diff_percentage = (np.max(counts) - np.min(counts)) / mean_count * 100

# Check if the maximum percentage difference is greater than 5%
if max_diff_percentage > 5.0:
    print(f"Warning: The maximum percentage difference in populations is {max_diff_percentage:.2f}% which is greater than 5%.")

# Plot the clusters and their boundaries
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
scatter = plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=1, cmap='viridis')

# Use a meshgrid for the boundary
h = .02
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))
Z = kmeans.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)
plt.contour(xx, yy, Z, levels=np.unique(Z), colors='blue', alpha=0.5)
plt.title('Cluster Boundaries')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')

# Plot a histogram to show the number of points in each cluster with colors matching the clusters
plt.subplot(1, 2, 2)
colors = scatter.cmap(scatter.norm(range(k)))
plt.bar(range(k), counts, color=colors, align='center')
plt.xticks(range(k))
plt.xlabel('Cluster')
plt.ylabel('Number of points')
plt.title('Number of points in each cluster')

# Add mean and max percentage difference as text below the histogram
plt.figtext(0.5, 0.01, f'Mean number of points per cluster: {mean_count:.2f}\n'
                       f'Max percentage difference in populations: {max_diff_percentage:.2f}%', 
            ha='center', fontsize=10)

plt.tight_layout()
plt.show()
